<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="classwx_reg_ex" kind="class" language="C++" prot="public">
    <compoundname>wxRegEx</compoundname>
    <includes local="no">wx/regex.h</includes>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classwx_reg_ex_1a6e10e9fd01041501fa31c17bf133b09f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>wxRegEx::wxRegEx</definition>
        <argsstring>()</argsstring>
        <name>wxRegEx</name>
        <briefdescription>
<para>Default constructor: use <ref refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" kindref="member">Compile()</ref> later. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="129" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a840f38773d86b3e8d6b02c120331c2cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>wxRegEx::wxRegEx</definition>
        <argsstring>(const wxString &amp;expr, int flags=wxRE_DEFAULT)</argsstring>
        <name>wxRegEx</name>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval><ref refid="regex_8h_1afa231099d07583c3ed0981e0bb665f55a2acc242d92915c6dc6f507d6be56b171" kindref="member">wxRE_DEFAULT</ref></defval>
        </param>
        <briefdescription>
<para>Create and compile the regular expression, use <ref refid="classwx_reg_ex_1a4310be2cd3560fbed8a59dc2c051d6c1" kindref="member">IsValid()</ref> to test for compilation errors. </para>
        </briefdescription>
        <detaileddescription>
<para>As for the flags, please see <ref refid="regex_8h_1wxRE_FLAGS" kindref="member">wxRE_FLAGS</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="137" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1aaf75e99c2dbe5fe8e798c64b1e510355" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>wxRegEx::~wxRegEx</definition>
        <argsstring>()</argsstring>
        <name>~wxRegEx</name>
        <briefdescription>
<para>Destructor. </para>
        </briefdescription>
        <detaileddescription>
<para>It&apos;s not virtual, don&apos;t derive from this class. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="143" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxRegEx::Compile</definition>
        <argsstring>(const wxString &amp;pattern, int flags=wxRE_DEFAULT)</argsstring>
        <name>Compile</name>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>pattern</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval><ref refid="regex_8h_1afa231099d07583c3ed0981e0bb665f55a2acc242d92915c6dc6f507d6be56b171" kindref="member">wxRE_DEFAULT</ref></defval>
        </param>
        <briefdescription>
<para>Compile the string into regular expression, return true if ok or false if string has a syntax error. </para>
        </briefdescription>
        <detaileddescription>
<para>As for the flags, please see <ref refid="regex_8h_1wxRE_FLAGS" kindref="member">wxRE_FLAGS</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="151" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a2f0bff22dd31a7f762a677afce2e26b5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxRegEx::GetMatch</definition>
        <argsstring>(size_t *start, size_t *len, size_t index=0) const</argsstring>
        <name>GetMatch</name>
        <param>
          <type>size_t *</type>
          <declname>start</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>len</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>index</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Get the start index and the length of the match of the expression (if <emphasis>index</emphasis> is 0) or a bracketed subexpression (<emphasis>index</emphasis> different from 0). </para>
        </briefdescription>
        <detaileddescription>
<para>May only be called after successful call to <ref refid="classwx_reg_ex_1a0d513567bfbfed1e6aa9c77b3fee19ff" kindref="member">Matches()</ref> and only if <computeroutput>wxRE_NOSUB</computeroutput> was <bold>not</bold> used in <ref refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" kindref="member">Compile()</ref>.</para>
<para>Returns false if no match or if an error occurred. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="163" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a704b4c45bbc1c74c0f21504ff228bed6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classwx_string" kindref="compound">wxString</ref></type>
        <definition>wxString wxRegEx::GetMatch</definition>
        <argsstring>(const wxString &amp;text, size_t index=0) const</argsstring>
        <name>GetMatch</name>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>text</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>index</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns the part of string corresponding to the match where index is interpreted as above. </para>
        </briefdescription>
        <detaileddescription>
<para>Empty string is returned if match failed.</para>
<para>May only be called after successful call to <ref refid="classwx_reg_ex_1a0d513567bfbfed1e6aa9c77b3fee19ff" kindref="member">Matches()</ref> and only if <computeroutput>wxRE_NOSUB</computeroutput> was <bold>not</bold> used in <ref refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" kindref="member">Compile()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="172" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a19d487c04d6d555208a88c78528a260b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t wxRegEx::GetMatchCount</definition>
        <argsstring>() const</argsstring>
        <name>GetMatchCount</name>
        <briefdescription>
<para>Returns the size of the array of matches, i.e. the number of bracketed subexpressions plus one for the expression itself, or 0 on error. </para>
        </briefdescription>
        <detaileddescription>
<para>May only be called after successful call to <ref refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" kindref="member">Compile()</ref>. and only if <computeroutput>wxRE_NOSUB</computeroutput> was <bold>not</bold> used. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="181" column="12"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a4310be2cd3560fbed8a59dc2c051d6c1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxRegEx::IsValid</definition>
        <argsstring>() const</argsstring>
        <name>IsValid</name>
        <briefdescription>
<para>Return true if this is a valid compiled regular expression, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="187" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a0d513567bfbfed1e6aa9c77b3fee19ff" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxRegEx::Matches</definition>
        <argsstring>(const wxChar *text, int flags=0) const</argsstring>
        <name>Matches</name>
        <param>
          <type>const <ref refid="chartype_8h_1ad42f64d8c82f1ce4ae58773a89b2d6a7" kindref="member">wxChar</ref> *</type>
          <declname>text</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Matches the precompiled regular expression against the string <emphasis>text</emphasis>, returns true if matches and false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para><emphasis>Flags</emphasis> may be combination of <computeroutput>wxRE_NOTBOL</computeroutput> and <computeroutput>wxRE_NOTEOL</computeroutput>, see <ref refid="regex_8h_1wxRE_NOT_FLAGS" kindref="member">wxRE_NOT_FLAGS</ref>.</para>
<para>Some regex libraries assume that the text given is null terminated, while others require the length be given as a separate parameter. Therefore for maximum portability assume that <emphasis>text</emphasis> cannot contain embedded nulls.</para>
<para>When the <bold>Matches(const wxChar *text, int flags = 0)</bold> form is used, a <ref refid="wxcrt_8h_1a8ee0fe62cfc16ac60a217e825dcf4ba5" kindref="member">wxStrlen()</ref> will be done internally if the regex library requires the length. When using <ref refid="classwx_reg_ex_1a0d513567bfbfed1e6aa9c77b3fee19ff" kindref="member">Matches()</ref> in a loop the <bold>Matches(text, flags, len)</bold> form can be used instead, making it possible to avoid a <ref refid="wxcrt_8h_1a8ee0fe62cfc16ac60a217e825dcf4ba5" kindref="member">wxStrlen()</ref> inside the loop.</para>
<para>May only be called after successful call to <ref refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" kindref="member">Compile()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="209" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1abb847625068a6f867786c9b6cddb9e82" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxRegEx::Matches</definition>
        <argsstring>(const wxChar *text, int flags, size_t len) const</argsstring>
        <name>Matches</name>
        <param>
          <type>const <ref refid="chartype_8h_1ad42f64d8c82f1ce4ae58773a89b2d6a7" kindref="member">wxChar</ref> *</type>
          <declname>text</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="210" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1adb9a749baf9c7b85523289b85d5e56b7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool wxRegEx::Matches</definition>
        <argsstring>(const wxString &amp;text, int flags=0) const</argsstring>
        <name>Matches</name>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>text</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Matches the precompiled regular expression against the string <emphasis>text</emphasis>, returns true if matches and false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para><emphasis>Flags</emphasis> may be combination of <computeroutput>wxRE_NOTBOL</computeroutput> and <computeroutput>wxRE_NOTEOL</computeroutput>, see <ref refid="regex_8h_1wxRE_NOT_FLAGS" kindref="member">wxRE_NOT_FLAGS</ref>.</para>
<para>May only be called after successful call to <ref refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" kindref="member">Compile()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="222" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1abbc4036c94fff3fb1a1ddc2b2088ff9d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int wxRegEx::Replace</definition>
        <argsstring>(wxString *text, const wxString &amp;replacement, size_t maxMatches=0) const</argsstring>
        <name>Replace</name>
        <param>
          <type><ref refid="classwx_string" kindref="compound">wxString</ref> *</type>
          <declname>text</declname>
        </param>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>replacement</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>maxMatches</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Replaces the current regular expression in the string pointed to by <emphasis>text</emphasis>, with the text in <emphasis>replacement</emphasis> and return number of matches replaced (maybe 0 if none found) or -1 on error. </para>
        </briefdescription>
        <detaileddescription>
<para>The replacement text may contain back references <computeroutput>\number</computeroutput> which will be replaced with the value of the corresponding subexpression in the pattern match. <computeroutput>\0</computeroutput> corresponds to the entire match and <computeroutput>&amp;</computeroutput> is a synonym for it. Backslash may be used to quote itself or <computeroutput>&amp;</computeroutput> character.</para>
<para><emphasis>maxMatches</emphasis> may be used to limit the number of replacements made, setting it to 1, for example, will only replace first occurrence (if any) of the pattern in the text while default value of 0 means replace all. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="238" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1adc3adca7b7c76ccab718336675f17325" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int wxRegEx::ReplaceAll</definition>
        <argsstring>(wxString *text, const wxString &amp;replacement) const</argsstring>
        <name>ReplaceAll</name>
        <param>
          <type><ref refid="classwx_string" kindref="compound">wxString</ref> *</type>
          <declname>text</declname>
        </param>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>replacement</declname>
        </param>
        <briefdescription>
<para>Replace all occurrences: this is actually a synonym for <ref refid="classwx_reg_ex_1abbc4036c94fff3fb1a1ddc2b2088ff9d" kindref="member">Replace()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classwx_reg_ex_1a5de12bf2b5873ec5b6ff9e3a378cabea" kindref="member">ReplaceFirst()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="247" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classwx_reg_ex_1a5de12bf2b5873ec5b6ff9e3a378cabea" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int wxRegEx::ReplaceFirst</definition>
        <argsstring>(wxString *text, const wxString &amp;replacement) const</argsstring>
        <name>ReplaceFirst</name>
        <param>
          <type><ref refid="classwx_string" kindref="compound">wxString</ref> *</type>
          <declname>text</declname>
        </param>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>replacement</declname>
        </param>
        <briefdescription>
<para>Replace the first occurrence. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="252" column="9"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classwx_reg_ex_1abe954141cbbeb6f92d19feb3f3550d28" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classwx_string" kindref="compound">wxString</ref></type>
        <definition>static wxString wxRegEx::QuoteMeta</definition>
        <argsstring>(const wxString &amp;str)</argsstring>
        <name>QuoteMeta</name>
        <param>
          <type>const <ref refid="classwx_string" kindref="compound">wxString</ref> &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Escapes any of the characters having special meaning for <ref refid="classwx_reg_ex" kindref="compound">wxRegEx</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Currently the following characters are special: \, ^, $, ., |, ?, *, +, (, ), [, ], { and }. All occurrences of any of these characters in the passed string are escaped, i.e. a backslash is inserted before them, to remove their special meaning.</para>
<para>For example: <programlisting><codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound">wxString</ref><sp/>quoted<sp/>=<sp/><ref refid="classwx_reg_ex_1abe954141cbbeb6f92d19feb3f3550d28" kindref="member">wxRegEx::QuoteMeta</ref>(</highlight><highlight class="stringliteral">&quot;foo.*bar&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">assert(<sp/>quoted<sp/>==<sp/>R</highlight><highlight class="stringliteral">&quot;(foo\.\*bar)&quot;<sp/>);</highlight></codeline>
</programlisting></para>
<para>This function can be useful when using <ref refid="classwx_reg_ex" kindref="compound">wxRegEx</ref> to search for a literal string entered by user, for example.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>str</parametername>
</parameternamelist>
<parameterdescription>
<para>A string that may contain metacharacters to escape.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A string with all metacharacters escaped.</para>
</simplesect>
<simplesect kind="since"><para>3.1.3 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="interface/wx/regex.h" line="278" column="21"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="classwx_reg_ex" kindref="compound">wxRegEx</ref> represents a regular expression. </para>
    </briefdescription>
    <detaileddescription>
<para>This class provides support for regular expressions matching and also replacement.</para>
<para>It is built on top of either the system library (if it has support for POSIX regular expressions - which is the case of the most modern Unices) or uses the built in Henry Spencer&apos;s library. Henry Spencer would appreciate being given credit in the documentation of software which uses his library, but that is not a requirement.</para>
<para>Regular expressions, as defined by POSIX, come in two flavours: <emphasis>extended</emphasis> and <emphasis>basic</emphasis>. The builtin library also adds a third flavour of expression <ref refid="overview_resyntax" kindref="compound">advanced</ref>, which is not available when using the system library.</para>
<para>Unicode is fully supported only when using the builtin library. When using the system library in Unicode mode, the expressions and data are translated to the default 8-bit encoding before being passed to the library.</para>
<para>On platforms where a system library is available, the default is to use the builtin library for Unicode builds, and the system library otherwise. It is possible to use the other if preferred by selecting it when building the wxWidgets.</para>
<para><heading level="2"></heading>
</para>
<para>Library:<nonbreakablespace/><nonbreakablespace/><ref refid="page_libs_1page_libs_wxbase" kindref="member">wxBase</ref> &lt;&gt;&lt; =&apos;&apos;&gt;:&lt;/&gt;&amp;;&amp;;&lt; =&apos;&apos;&gt;\ &lt;/&gt;&lt;/&gt;</para>
<para>Example:</para>
<para>A (bad) example of processing some text containing email addresses (the example is bad because the real email addresses can have more complicated form than <computeroutput><ulink url="mailto:user@host.net">user@host.net</ulink></computeroutput>):</para>
<para><programlisting><codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound">wxString</ref><sp/>originalText<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>some<sp/>text<sp/>with<sp/>foo@example.com<sp/>and<sp/>bar@example.com&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Regex.<sp/>to<sp/>match<sp/>an<sp/>email<sp/>address<sp/>and<sp/>extract<sp/>its<sp/>subparts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classwx_reg_ex" kindref="compound">wxRegEx</ref><sp/>reEmail(</highlight><highlight class="stringliteral">&quot;([^@<sp/>-]+)@([[:alnum:]_]+).([[:alnum:]]{2,4})&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound">wxString</ref><sp/>processText<sp/>=<sp/>originalText;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(<sp/>reEmail.Matches(processText)<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>size<sp/>of<sp/>the<sp/>first<sp/>match<sp/>and<sp/>print<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>start,<sp/>len;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reEmail.GetMatch(&amp;start,<sp/>&amp;len,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Email:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reEmail.GetMatch(processText,<sp/>0)<sp/>&lt;&lt;<sp/><ref refid="txtstrm_8h_1a696f69d76df63d35e1d28df1cc6f9532" kindref="member">std::endl</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>submatches.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Name:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reEmail.GetMatch(processText,<sp/>1)<sp/>&lt;&lt;<sp/><ref refid="txtstrm_8h_1a696f69d76df63d35e1d28df1cc6f9532" kindref="member">std::endl</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Domain:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reEmail.GetMatch(processText,<sp/>2)<sp/>&lt;&lt;<sp/><ref refid="txtstrm_8h_1a696f69d76df63d35e1d28df1cc6f9532" kindref="member">std::endl</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;TLD:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>reEmail.GetMatch(processText,<sp/>3)<sp/>&lt;&lt;<sp/><ref refid="txtstrm_8h_1a696f69d76df63d35e1d28df1cc6f9532" kindref="member">std::endl</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>the<sp/>remainder<sp/>of<sp/>the<sp/>text<sp/>if<sp/>there<sp/>is<sp/>any.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>processText<sp/>=<sp/>processText.<ref refid="classwx_string_1ae28d32ca35ae00e3225fc25496a77f93" kindref="member">Mid</ref><sp/>(start<sp/>+<sp/>len);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Or<sp/>this<sp/>will<sp/>replace<sp/>all<sp/>names<sp/>with<sp/>&quot;HIDDEN&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>reEmail.ReplaceAll(&amp;originalText,<sp/></highlight><highlight class="stringliteral">&quot;HIDDEN@\\2.\\3&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;text<sp/>now<sp/>contains<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>count<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>hidden<sp/>addresses&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="txtstrm_8h_1a696f69d76df63d35e1d28df1cc6f9532" kindref="member">std::endl</ref>;</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/>originalText<sp/>&lt;&lt;<sp/><ref refid="txtstrm_8h_1a696f69d76df63d35e1d28df1cc6f9532" kindref="member">std::endl</ref>;</highlight></codeline>
</programlisting> </para>
    </detaileddescription>
    <location file="interface/wx/regex.h" line="122" column="1" bodyfile="interface/wx/regex.h" bodystart="123" bodyend="279"/>
    <listofallmembers>
      <member refid="classwx_reg_ex_1acd01c4ab52213184f89a1e9a36bc1a24" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>Compile</name></member>
      <member refid="classwx_reg_ex_1a2f0bff22dd31a7f762a677afce2e26b5" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>GetMatch</name></member>
      <member refid="classwx_reg_ex_1a704b4c45bbc1c74c0f21504ff228bed6" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>GetMatch</name></member>
      <member refid="classwx_reg_ex_1a19d487c04d6d555208a88c78528a260b" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>GetMatchCount</name></member>
      <member refid="classwx_reg_ex_1a4310be2cd3560fbed8a59dc2c051d6c1" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>IsValid</name></member>
      <member refid="classwx_reg_ex_1a0d513567bfbfed1e6aa9c77b3fee19ff" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>Matches</name></member>
      <member refid="classwx_reg_ex_1abb847625068a6f867786c9b6cddb9e82" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>Matches</name></member>
      <member refid="classwx_reg_ex_1adb9a749baf9c7b85523289b85d5e56b7" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>Matches</name></member>
      <member refid="classwx_reg_ex_1abe954141cbbeb6f92d19feb3f3550d28" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>QuoteMeta</name></member>
      <member refid="classwx_reg_ex_1abbc4036c94fff3fb1a1ddc2b2088ff9d" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>Replace</name></member>
      <member refid="classwx_reg_ex_1adc3adca7b7c76ccab718336675f17325" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>ReplaceAll</name></member>
      <member refid="classwx_reg_ex_1a5de12bf2b5873ec5b6ff9e3a378cabea" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>ReplaceFirst</name></member>
      <member refid="classwx_reg_ex_1a6e10e9fd01041501fa31c17bf133b09f" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>wxRegEx</name></member>
      <member refid="classwx_reg_ex_1a840f38773d86b3e8d6b02c120331c2cb" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>wxRegEx</name></member>
      <member refid="classwx_reg_ex_1aaf75e99c2dbe5fe8e798c64b1e510355" prot="public" virt="non-virtual"><scope>wxRegEx</scope><name>~wxRegEx</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
