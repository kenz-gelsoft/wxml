<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="overview_high_dpi" kind="page">
    <compoundname>overview_high_dpi</compoundname>
    <title>High DPI Support in wxWidgets</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="overview_high_dpi_1md_docs_doxygen_overviews_high_dpi"/></para>
<sect1 id="overview_high_dpi_1autotoc_md0">
<title>Introduction</title>
<para>Many modern displays have way more pixels on the same surface than used to be the norm, resulting in much higher values of DPI (dots, i.e. pixels, per inch) than the traditionally used values. This allows to render texts, or geometric shapes in general much more smoothly.</para>
<para>As an illustration here are two scaled up views of the same text in 11 pt Helvetica using up the same space on screen. First on an original Mac display at 72 dpi, then on a High DPI Display, called &quot;Retina&quot; by Apple with twice as many pixels in both dimensions (144 dpi), thus 4 times the number of pixels on the same surface. Using these the contours are much more detailed.</para>
<para><image type="html" name="overview_highdpi_text_72.png" inline="yes">11 pt Helvetica at 72 DPI</image>
<image type="latex" name="overview_highdpi_text_72.png" inline="yes">11 pt Helvetica at 72 DPI</image>
<image type="rtf" name="overview_highdpi_text_72.png" inline="yes">11 pt Helvetica at 72 DPI</image>
<image type="docbook" name="overview_highdpi_text_72.png" inline="yes">11 pt Helvetica at 72 DPI</image>
</para>
<para><image type="html" name="overview_highdpi_text_144.png" inline="yes">11 pt Helvetica at 144 DPI</image>
<image type="latex" name="overview_highdpi_text_144.png" inline="yes">11 pt Helvetica at 144 DPI</image>
<image type="rtf" name="overview_highdpi_text_144.png" inline="yes">11 pt Helvetica at 144 DPI</image>
<image type="docbook" name="overview_highdpi_text_144.png" inline="yes">11 pt Helvetica at 144 DPI</image>
</para>
<para>To the user the DPI is typically expressed using a scaling factor, by which the baseline DPI value is multiplied. For example, MSW systems may use 125% or 150% scaling, meaning that they use DPI of 120 or 144 respectively, as baseline DPI value is 96. Similarly, Linux systems may use &quot;2x&quot; scaling, resulting in DPI value of 192. Macs are slightly different, as even they also may use &quot;2x&quot; scaling, as in the example above, the effective DPI corresponding to it is 144, as the baseline value on this platform is 72.</para>
<sect2 id="overview_high_dpi_1autotoc_md1">
<title>The Problem with High DPI Displays</title>
<para>If high DPI displays were treated in the same way as normal ones, existing applications would look tiny of them. For example, a square window 500 pixels in size would take half of a standard 1920×1080 (&quot;Full HD&quot;) display vertically, but only a quarter on a 3840×2160 (&quot;4K UHD&quot;) display. To prevent this from happening, most platforms automatically scale the windows by the scaling factor, defined above, when displaying them on high DPI displays. In this example, scaling factor is 2 and so the actual size of the window on screen would become 1000 when automatic scaling is in effect.</para>
<para>Automatic scaling is convenient, but doesn&apos;t really allow the application to use the extra pixels available on the display. Visually, this means that the scaled application appears blurry, in contrast to sharper applications using the full display resolution, so a better solution for interpreting pixel values on high DPI displays is needed: one which allows to scale some pixel values (e.g. the total window size), but not some other ones (e.g. those used for drawing, which should remain unscaled to use the full available resolution).</para>
</sect2>
</sect1>
<sect1 id="overview_high_dpi_1autotoc_md2">
<title>Pixel Values in wxWidgets</title>
<sect2 id="overview_high_dpi_1autotoc_md3">
<title>Logical and Device-Independent Pixels</title>
<para>Some systems like eg Apple&apos;s OSes automatically scale all the coordinates by the DPI scaling factor, however not all systems supported by wxWidgets do it <ndash/> notably, MSW does not. This means that <bold>logical pixels</bold>, in which all coordinates and sizes are expressed in wxWidgets API, do <emphasis>not</emphasis> have the same meaning on all platforms when using high DPI displays. So while on macOS you can always pass in a size of (500,500) to create the window from the previous paragraph, whatever the resolution of the display is, you would have to increase this to (1000,1000) on MSW when working on a 200% display. To hide this difference from the application, wxWidgets provides <bold>device-independent pixels</bold>, abbreviated as &quot;DIP&quot;, that are always of the same size on all displays and all platforms.</para>
<para>Thus, the first thing do when preparing your application for high DPI support is to stop using raw pixel values. Actually, using any pixel values is not recommended and replacing them with the values based on the text metrics, i.e. obtained using <ref refid="classwx_window_1a4220668e42f3a173bf29d335da4db2c3" kindref="member">wxWindow::GetTextExtent()</ref>, or expressing them in dialog units (see <ref refid="classwx_window_1a3dbe034120d742c4f5f6d64dc5d69590" kindref="member">wxWindow::ConvertDialogToPixels()</ref>) is preferable. However the simplest change is to just replace the pixel values with the values in DIP: for this, just use <ref refid="classwx_window_1a4b0a9da72d28465bdf5c0bfe5661cdf9" kindref="member">wxWindow::FromDIP()</ref> to convert from one to the other.</para>
<para>For example, if you have the existing code: <programlisting filename=".cpp"><codeline><highlight class="normal">myFrame-&gt;SetClientSize(<ref refid="classwx_size" kindref="compound">wxSize</ref>(400,<sp/>300));</highlight></codeline>
</programlisting> you can just replace it with <programlisting filename=".cpp"><codeline><highlight class="normal">myFrame-&gt;SetClientSize(myFrame-&gt;FromDIP(<ref refid="classwx_size" kindref="compound">wxSize</ref>(400,<sp/>300)));</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="overview_high_dpi_1autotoc_md4">
<title>Physical Pixels</title>
<para>In addition to (logical) pixels and DIPs discussed above, you may also need to work in physical pixel coordinates, corresponding to the actual display pixels. Physical pixels are never scaled, on any platform, and must be used when drawing graphics elements to ensure that the best possible resolution is used. For example, all operations on <ref refid="classwx_g_l_canvas" kindref="compound">wxGLCanvas</ref> use physical pixels.</para>
<para>To convert between logical and physical pixels, you can use <ref refid="classwx_window_1a89cbf94bc15d4e8cb5b1e7db85225577" kindref="member">wxWindow::GetContentScaleFactor()</ref>: this is a value greater than or equal to 1, so a value in logical pixels needs to be multiplied by it in order to obtain the value in physical pixels.</para>
<para>For example, in a <ref refid="classwx_g_l_canvas" kindref="compound">wxGLCanvas</ref> created with the size of 100 (logical) pixels, the rightmost physical pixel coordinate will be <computeroutput>100*GetContentScaleFactor()</computeroutput>.</para>
</sect2>
</sect1>
<sect1 id="overview_high_dpi_1autotoc_md5">
<title>High-Resolution Images and Artwork</title>
<para>In order to benefit from the increased detail on High DPI devices you might want to provide the images or artwork your application uses in higher resolutions as well. Note that it is not recommended to just provide a high-resolution version and let the system scale that down on 1x displays. Apart from performance consideration also the quality might suffer, contours become more blurry.</para>
<para>You can use vector based graphics like SVG or you can add the same image at different sizes / resolutions.</para>
</sect1>
<sect1 id="overview_high_dpi_1autotoc_md6">
<title>Platform-Specific Build Issues</title>
<para>Generally speaking, all systems handle applications not specifically marked as being &quot;DPI-aware&quot; by emulating low-resolution display for them and scaling them up, resulting in blurry graphics and fonts, but globally preserving the application appearance. For the best results, the application needs to be explicitly marked as DPI-aware in a platform-dependent way.</para>
<sect2 id="overview_high_dpi_1autotoc_md7">
<title>MSW</title>
<para>The behaviour of the application when running on a high-DPI display depends on the values in its <ulink url="https://docs.microsoft.com/en-us/windows/win32/sbscs/application-manifests">manifest</ulink>. If your application include <computeroutput>wx/msw/wx.rc</computeroutput> from its resource file, you need to predefine <computeroutput>wxUSE_DPI_AWARE_MANIFEST</computeroutput> to opt-in into <ulink url="https://docs.microsoft.com/en-us/windows/win32/hidpi/high-dpi-desktop-application-development-on-windows">high DPI support</ulink>: define it as <computeroutput>1</computeroutput> for minimal DPI awareness and <computeroutput>2</computeroutput> for full, per-monitor DPI awareness supported by Windows 10 version 1703 or later.</para>
</sect2>
<sect2 id="overview_high_dpi_1autotoc_md8">
<title>macOS</title>
<para>DPI-aware applications must set their <computeroutput>NSPrincipalClass</computeroutput> to <computeroutput>wxNSApplication</computeroutput> (or at least <computeroutput>NSApplication</computeroutput>) in their <computeroutput>Info.plist</computeroutput> file. Also see Apple <ulink url="https://docs.microsoft.com/en-us/windows/win32/hidpi/high-dpi-desktop-application-development-on-windows">high resolution guidelines</ulink> for more information. </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="docs/doxygen/overviews/high_dpi.md"/>
  </compounddef>
</doxygen>
